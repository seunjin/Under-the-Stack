# 커리큘럼 및 학습 설계 전략 (Curriculum & Learning Strategy)

본 프로젝트는 단순한 지식 전달을 넘어, 웹 엔지니어가 복잡한 시스템의 동작 원리를 꿰뚫어 볼 수 있는 **'시스템 사고(System Thinking)'** 능력을 배양하는 것을 최우선 목표로 합니다.

---

## 1. 커리큘럼 구조 (2-Track System)

### 🟢 Level 0. Beginner Foundations (입문)
**목표: "CS는 무섭지 않다" - 직관적 이해와 시스템적 사고의 시작**
- **대상**: CS 용어를 처음 접하거나 막연한 두려움을 가진 초보자
- **전략**: 
  - 비유와 그림 중심의 설명 (예: 배열은 '아파트 복도', 스택은 '프링글스 통')
  - 수학적 기호 및 수식 최소화
  - **Big-O 표기 배제**: "처리 시간이 늘어나는 느낌"에 집중
  - **개별 전용 시뮬레이터 (Dedicated Visualizers)**: 각 개념에 최적화된 독립적 UI 제공 (예: 해시 테이블 전용 뷰)

### 🔵 Level 1. Applied Frontend Systems (실무 연결)
**목표: "내가 짠 코드가 브라우저에서 어떻게 돌아가는가?" - 프론트엔드 전문성 확보**
- **대상**: React나 JavaScript를 다루지만 내부 원리를 깊이 이해하고 싶은 개발자
- **전략**:
  - React, 브라우저 렌더링, JS Runtime 스펙 중심의 재해석
  - 성능 병목 지점을 판단할 수 있는 공학적 감각 배양
  - **통합 시스템 시뮬레이터 (Integrated Runtime View)**: Call Stack, Memory(Heap), Task Queue가 유기적으로 상호작용하는 JS 실행 환경의 전체 모습 가시화


---

## 2. 핵심 개념 별 연결 구조 (Core 6)

| CS 개념 (Level 0) | 프론트엔드 실무 매핑 (Level 1) | 연결 흐름 (Bridge) |
| :--- | :--- | :--- |
| **시간복잡도 (Complexity)** | 성능 병목 판단 감각 | "데이터가 많아질 때 리스트 렌더링이 왜 느려질까?" |
| **배열 (Array)** | React 리스트 렌더링 비용 | 연속된 데이터 구조와 `map()` 상의 인덱스 접근 효율 |
| **스택 (Stack)** | Call Stack & Error Trace | 함수 실행 순서와 에러가 발생했을 때 거슬러 올라가는 법 |
| **큐 (Queue)** | Event Loop (Task Queue) | 클릭 이벤트와 타이머가 '순서대로' 처리되는 원리 |
| **해시 (Hash)** | 캐싱 (Memoization) & Map | 중복 계산을 피하기 위해 결과를 이름표(Key) 붙여 저장하기 |
| **트리 (Tree)** | DOM / Virtual DOM | 부모-자식 관계의 데이터가 화면에 그려지는 구조 |

---

## 3. 학습 설계 원칙 (Pedagogy)

### 📈 학습 난이도 상승 곡선 (Difficulty Gradient)
1.  **발견 (Discovery)**: 일상생활의 비유로 개념의 필요성을 깨닫습니다.
2.  **관찰 (Observation)**: 시뮬레이션으로 데이터가 흘러가는 모습을 눈으로 봅니다.
3.  **매핑 (Mapping)**: "이게 사실은 React의 그 기능이다"라는 사실을 발견합니다.
4.  **확장 (Expansion)**: 더 복잡한 프론트엔드 성능 최적화 사례에 적용해 봅니다.

### 🛡️ 중도 포기 방지 전략
- **No-Code First**: 초기 단계에서 문법 오류로 좌절하지 않도록 시뮬레이터 조작을 우선합니다.
- **Immediate Feedback**: 시뮬레이션 단계마다 "지금 이 데이터는 어디로 갈까요?"와 같은 퀴즈를 제공합니다.
- **Aha-Moment Focus**: 지루한 이론 나열보다 실무 고민(ex. 리렌더링 최적화)을 해결해 주는 지점을 강조합니다.

---

## 4. 향후 확장성 (Scalability)

현재는 프론트엔드에 집중하지만, 향후 **Level 2. Backend & Infrastructure** 트랙을 자연스럽게 추가할 수 있도록 설계되었습니다.
- 배열/리스트 → DB 인덱싱 및 스캔 효율
- 큐 → 메시지 브로커 (Kafka, RabbitMQ)
- 트리 → 파일 시스템 및 인덱스 트리 (B-Tree)

---

## 5. 시뮬레이션 아키텍처 (Dedicated vs Integrated)

본 플랫폼은 개념의 복잡도와 학습 단계에 따라 두 가지 시뮬레이션 모드를 제공합니다.

### 🟢 전용 비주얼라이저 (Dedicated Visualizer) - Level 0 중심
특정 데이터 구조나 알고리즘의 **핵심 원리**만을 고립시켜 시각화합니다.
- **장점**: 인지 부하 감소, 특정 개념에 대한 명확한 심상 형성.
- **방식**: 콜 스택 등 부수적인 런타임 요소는 감추고, 오직 데이터의 변화와 탐색 과정에만 집중합니다.

### 🔵 통합 런타임 뷰 (Integrated Runtime View) - Level 1 중심
여러 부품이 JavaScript 엔진 내에서 어떻게 **유기적으로 통합**되어 작동하는지 가시화합니다.
- **구성**: Call Stack + Heap(Memory) + Task Queue + Event Loop.
- **목적**: 개별 부품의 원리를 넘어, 시스템 전체의 흐름을 파악하는 '시스템 사고'를 완성합니다.

---

## 6. 톤앤매너 및 교습 방법론 (Instructional Style)

학습 타겟을 **대학생 및 성인 비전공자** 수준으로 격상하고, 단순 지식 전달이 아닌 **'친근한 기술 멘토'**가 옆에서 설명해 주는 듯한 **구어체 기반의 기술 블로그 스타일**을 지향합니다.

### ✍️ 문체 및 어조 가이드
1.  **친근한 멘토링**: "자, 여러분", "한번 상상해 볼까요?", "이 부분이 핵심이에요"와 같이 학습자의 심리적 장벽을 낮춰주는 부드러운 구어체(경어체)를 사용합니다. 
    > [!IMPORTANT]
    > '선배'라는 특정 호칭이나 개인적인 인명(Jin 등)을 직접적으로 노출하는 것은 지양하며, 보편적인 멘토의 입장에서 서술합니다.
2.  **기술 블로그 레이아웃**: 섹션을 명확히 분리하고, 각 섹션마다 리드미컬한 소제목을 붙여 긴 글도 지루하지 않게 읽히도록 구성합니다.
3.  **전문성과 친근함의 조화**: 원리 설명은 엄밀하되, 표현은 부드럽게 유지합니다. 너무 유치한 비유는 지양하고, 실무적인 고민을 함께 나누는 논조를 유지합니다.

### 🎓 교습 프로세스 (Instructional Mapping)
모든 레슨은 다음 흐름을 엄격히 따릅니다.

1.  **공감과 문제 제기**: 현업에서 마주칠 법한 고민이나 시스템의 한계를 먼저 제시하여 학습의 동기(Why)를 부여합니다.
2.  **단계별 빌드업**: 갑작스러운 개념 투척이 아닌, 생각을 확장해 나가는 흐름으로 설명합니다. (A -> B -> 그래서 C!)
3.  **시각적 링크**: "지금 보시는 시뮬레이터의 움직임이 바로 이 코드의 원리입니다"와 같이 이론과 시각화를 끊임없이 연결합니다.
4.  **클로징 가이드**: 당장 다음 프로젝트에서 적용할 수 있는 마인드셋을 전수하며 마무리합니다.

---

## 7. 교수법 및 학습 프로세스
모든 레슨은 다음 3단계를 엄격히 따릅니다.

1.  **Concept Exploration**: 비유적 접근을 통해 개념의 필요성(Why)을 공학적으로 제시.
2.  **Interactive Simulation**: 시뮬레이터와 설명 섹션의 유기적 결합을 통한 경험적 학습.
3.  **Real-world Context**: 실제 소스 코드 조각(React/JS)을 보며 개념의 실체를 확인.

