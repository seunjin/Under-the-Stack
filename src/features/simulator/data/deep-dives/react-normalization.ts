import type { DeepDive } from '../../lib/types'

export const reactNormalizationDeepDive: DeepDive = {
  id: 'react-normalization',
  lessonId: 'complexity',
  title: 'React 상태 정규화 패턴 (Normalization)',
  content: `
# React 상태 정규화, 어렵게 말하면 설계이고 쉽게 말하면 "찾기 쉽게 정리하기"입니다

앞 레슨에서 "조회 경로를 바꾸면 비용이 바뀐다"는 감각을 잡았습니다.  
이제 그걸 React/Next 실무로 가져와 보겠습니다.

<callout variant="info" title="이 글의 권장 진입 순서">
이 글은 \`complexity\` 기반의 선택 심화입니다.  
가능하면 \`array\`와 \`hash-table\` 레슨까지 먼저 본 뒤 읽어주세요.  
배열 순회와 해시 조회 감각이 잡힌 상태에서 읽으면 이해 속도가 훨씬 빨라집니다.
</callout>

정규화(Normalization)를 한 줄로 말하면 이렇습니다.

> 중첩된 데이터를 펼치고, ID로 연결해서, 필요한 데이터를 즉시 찾게 만드는 구조화.

용어는 어려워 보여도, 실제로는 "서랍 정리"에 가깝습니다.

---

### 먼저 왜 필요한지부터 이야기해 볼게요

초기에는 아래처럼 중첩 구조가 읽기 쉽습니다.

\`\`\`javascript
const posts = [
  {
    id: 'post1',
    title: 'Hello',
    comments: [{ id: 'c1', content: 'Great!' }],
  },
]
\`\`\`

문제는 기능이 늘어날 때 생깁니다.  
댓글 하나를 수정해야 하거나, 특정 유저가 쓴 댓글만 골라야 하거나, 같은 데이터를 여러 화면에서 동시에 보여줘야 하는 순간이 오면  
매번 배열을 순회하고 중첩 객체를 불변 업데이트하는 비용이 빠르게 커집니다.  
코드는 길어지고, 데이터가 커질수록 체감 성능도 눈에 띄게 떨어지기 시작합니다.

<callout variant="info" title="주니어가 자주 겪는 신호">
"기능 하나 추가했는데 setState 코드가 너무 길어졌다"  
"find/map/filter가 여러 번 중첩된다"  
이 두 가지가 보이면 정규화 후보입니다.
</callout>

---

### 비유로 이해해 봅시다: "주소 없는 창고"와 "라벨이 붙은 창고"

#### 주소 없는 창고 (비정규화)
물건은 쌓여 있는데 위치 체계가 없습니다.  
필요한 물건을 찾으려면 상자를 하나씩 열어봐야 합니다.

#### 라벨이 붙은 창고 (정규화)
모든 상자에 ID 라벨이 있고, 위치표(인덱스)가 있습니다.  
ID를 알면 바로 접근 가능합니다.

프론트엔드 상태도 같습니다.  
정규화는 데이터 구조를 "찾기 쉬운 창고"로 바꾸는 작업입니다.

---

### 데이터 구조를 실제로 어떻게 바꾸는지 볼게요

\`\`\`javascript
{
  posts: {
    byId: {
      post1: { id: 'post1', title: 'Hello', comments: ['c1', 'c2'] }
    },
    allIds: ['post1']
  },
  comments: {
    byId: {
      c1: { id: 'c1', content: 'Great!' }
    },
    allIds: ['c1']
  }
}
\`\`\`

<callout variant="idea" title="용어를 쉬운 말로">
\`byId\`: ID로 바로 찾는 사전(lookup table)  
\`allIds\`: 렌더 순서를 유지하는 목록  
둘을 같이 쓰면 "빠른 조회"와 "안정적인 렌더 순서"를 동시에 가져갈 수 있습니다.
</callout>

---

### 실무에서는 상태 역할을 나눠서 생각하면 훨씬 쉬워집니다

실무에서 흔히 헷갈리는 지점이 "무엇을 어디에 저장하나?"입니다.

서버에서 받아온 원본 응답과 캐시는 React Query에 맡기고,  
화면 상호작용이나 편집 중심 상태는 Zustand, Redux, 혹은 로컬 상태에서 다루는 식으로 역할을 나누면 설계가 깔끔해집니다.  
그리고 조회 비용이 큰 엔티티는 정규화 구조로 분리해 두면, 성능과 유지보수성을 함께 챙기기 좋습니다.

즉, React Query를 "자동 정규화 엔진"으로 기대하기보다,  
필요한 화면에서 정규화 모델을 명시적으로 두는 게 더 예측 가능합니다.

---

### 코드에서 어떤 차이가 나는지 천천히 비교해 볼게요

#### ❌ 반복 탐색이 렌더 경로에 섞인 형태
\`\`\`javascript
const PostView = ({ postId }) => {
  const post = posts.find((p) => p.id === postId)
  return <div>{post?.title}</div>
}
\`\`\`

#### ✅ 조회 경로가 고정된 형태
\`\`\`javascript
const PostView = ({ postId }) => {
  const post = usePostStore((state) => state.posts.byId[postId])
  return <div>{post?.title}</div>
}
\`\`\`

차이는 단순 성능만이 아닙니다.  
후자는 "어디서 데이터를 가져오는지"가 명확하고, 조회 경로가 고정되어 있기 때문에 코드 리뷰와 유지보수도 한결 쉬워집니다.

---

### 언제 도입하면 좋을지, 실무 감각으로 정리해 볼게요

같은 엔티티를 여러 화면에서 함께 참조하고 있고, 특정 항목 조회가 자주 일어나며, 중첩 불변 업데이트 코드가 반복된다면 정규화를 진지하게 검토할 시점입니다.  
특히 렌더 전에 하는 데이터 가공이 무겁게 느껴지기 시작했다면, 대부분은 구조를 바꿨을 때 효과가 큽니다.  
반대로 데이터 규모가 작고 변경 흐름이 단순한 화면이라면, 오히려 정규화보다 단순 배열이 더 좋은 선택일 수 있습니다.

<callout variant="warning" title="과도한 추상화 주의">
정규화는 만능이 아닙니다.  
팀 숙련도와 문제 크기를 같이 보고 도입해야 교육비용/유지보수비용을 줄일 수 있습니다.
</callout>

---

### 마지막으로, 이해를 굳히는 연습을 제안할게요

지금 가지고 있는 댓글 배열 상태를 \`comments.byId + comments.allIds\` 구조로 직접 바꿔보세요.  
그다음 댓글 내용 수정 함수를 한 번 작성해 보고, 기존 방식과 코드 길이와 가독성을 비교해 보시면 좋습니다.  
마지막으로 조회 경로에 주석을 달아 "여기는 O(N), 여기는 평균 O(1)"처럼 스스로 표시해 보면, 추상 개념이 실제 감각으로 빠르게 바뀝니다.

이 과정을 한번 해보면, 정규화는 더 이상 추상 개념이 아니라  
"서비스가 커질 때 버티는 구조"로 체감될 겁니다.
`,
}
